{
	"me": {
		"prefix": "me",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"void solve()",
			"{",
			"    $0",
			"}",
			"",
			"signed main()",
			"{",
			"    #ifndef ONLINE_JUDGE",
			"        freopen(\"/home/om/Acads/Codeforces-Contests/input.txt\", \"r\", stdin);",
			"        freopen(\"/home/om/Acads/Codeforces-Contests/output.txt\", \"w\", stdout);",
			"    #endif",
			"",
			"    ios_base::sync_with_stdio(0);",
			"    cin.tie(NULL);cout.tie(NULL);",
			"    ",
			"    solve();",
			"",
			"    return 0;",
			"}"
		],
		"description": "me"
	  },

	"testme": {
		"prefix": "testme",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"void solve()",
			"{",
			"    $0",
			"}",
			"",
			"signed main()",
			"{",
			"    #ifndef ONLINE_JUDGE",
			"        freopen(\"/home/om/Acads/Codeforces-Contests/input.txt\", \"r\", stdin);",
			"        freopen(\"/home/om/Acads/Codeforces-Contests/output.txt\", \"w\", stdout);",
			"    #endif",
			"",
			"    ios_base::sync_with_stdio(0);",
			"    cin.tie(NULL);cout.tie(NULL);",
			"    ",
			"    int Testcases;",
			"    cin>>Testcases;",
			"    while(Testcases--)solve();",
			"    ",
			"    return 0;",
			"}"
		],
		"description": "test cases"
	  },

	  "arrayinput": {
		"prefix": "arrrrrinp",
		"body": [
		  "vector<int> ar(N);",
		  "for(int i=0;i<N;i++)",
		  "{",
		  "    cin>>ar[i];",
		  "}"
		],
		"description": "arrayinput"
	  },

	  "power with modulo": {
		"prefix": "modulo_power",
		"body": [
		  "int power(int x, int y, int p)",
		  "{",
		  "    int res = 1;",
		  "    while (y > 0)",
		  "    {",
		  "        if (y % 2 == 1)",
		  "        res = (res * x)%p;",
		  "",
		  "        y = y >> 1;",
		  "        x = (x * x) % p;",
		  "    }",
		  "    return res % p;",
		  "}"
		],
		"description": "power with modulo"
	  },

		"Division MOD": {
		"prefix": "div_modulo",
		"body": [
			"int modInverse(unsigned long long n,  int MOD)",
			"{",
			"    return power(n, MOD - 2, MOD);",
			"}"
		],
		"description": "Division MOD"
	},

		"Combinator": {
		"prefix": "mod_comb",
		"body": [
			"int Combinator(int N,int K)",
			"{",
			"    return ((((fac[N] * modInverse(fac[K], MOD) )% MOD)* modInverse(fac[N - K], MOD)) % MOD)% MOD;",
			"}"
		],
		"description": "Combinator"
	},

		"Factorial": {
		"prefix": "mod_factorial",
		"body": [
			"int fac[(int)1e5+1];",
			"",
			"void calcFactorial()",
			"{",
			"    fac[0] = 1;",
			"    for(int i=1;i<1e5+1;i++)",
			"    {",
			"        fac[i] = (fac[i-1] * i)%MOD;",
			"    }",
			"}"
		],
		"description": "Factorial"
	},

	  "largest sum of a subarray": {
		"prefix": "max_subarr_sum",
		"body": [
		  "int largestsubarrsum(int* arr,int N)",
		  "{",
		  "    int sum = arr[0],maxsum = arr[0];",
		  "    if(sum<=0)sum=0;",
		  "",
		  "    for(int i=1;i<N;i++)",
		  "    {",
		  "        sum+=arr[i];",
		  "        maxsum = max(maxsum,sum);",
		  "        sum = max(sum,0)",
		  "    }",
		  "",
		  "    return maxsum;",
		  "}"
		],
		"description": "largest sum of a subarray"
	  },

	  "tree input using vector of vectors": {
		"prefix": "list_graph_input",
		"body": [
		  "vector<vector<int>> graph(N+1);",
		  "",
		  "for(int i=0;i<N-1;i++)",
		  "{",
		  "    int u,v;",
		  "    cin>>u>>v;",
		  "",
		  "    graph[u].push_back(v);",
		  "    graph[v].push_back(u);",
		  "}"
		],
		"description": "graph input using vector of vectors"
	  },

	"Graph input with cost": {
	"prefix": "costGraphInp",
	"body": [
		"vector<vector<pair<int,int>>> graph(N+1);",
		"    ",
		"for(int i=0;i<M;i++)",
		"{",
		"    int u,v,c;",
		"    cin>>u>>v>>c;",
		"",
		"    graph[u].push_back({v,c});",
		"    graph[v].push_back({u,c});",
		"}"
	],
	"description": "Graph input with cost"
	},

	  "Find all factors of a number": {
		"prefix": "findfactors",
		"body": [
		  "vector<int> factors;",
		  "",
		  "void findfactors(int N)",
		  "{",
		  "    int sqroot = (int)sqrt(N);",
		  "    for(int i = 1; i <= sqroot; i++)",
		  "    {",
		  "        if(N % i == 0)",
		  "        {",
		  "            factors.push_back(i);",
		  "            factors.push_back(N/i);",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "Find all factors of a number"
	  },

	"Segment Tree Template": {
		"prefix": "SegTree",
		"body": [
			"const int nullval = 0;",
			"int getOp(int x,int y){return x+y;}",
			"",
			"int getSTOp(vector<int> & st,int l,int r,int x,int lx,int rx)",
			"{",
			"    if(lx >= r || rx <= l)return nullval;",
			"    if(lx >= l && rx <= r)return st[x];",
			"",
			"    int mid = (lx+rx)>>1;",
			"    int res1 = getSTOp(st,l,r,2*x+1,lx,mid);",
			"    int res2 = getSTOp(st,l,r,2*x+2,mid,rx);",
			"    return getOp(res1,res2);",
			"}",
			"",
			"int getSTWrapper(vector<int> & st,int l,int r)",
			"{",
			"    return getSTOp(st,l,r,0,0,(st.size()+1)/2);",
			"}",
			"",
			"void setSTVal(vector<int> & st,int l,int r,int x,int lx,int rx,int val)",
			"{",
			"    if(rx <= l || lx >= r)return;",
			"    if(lx + 1 < rx)",
			"    {",
			"        int mid = (lx + rx)>>1;",
			"        setSTVal(st,l,r,2*x+1,lx,mid,val);",
			"        setSTVal(st,l,r,2*x+2,mid,rx,val);",
			"",
			"        st[x] = getOp(st[2*x+1],st[2*x+2]);",
			"    }",
			"    else st[x] = val;",
			"}",
			"",
			"void setSTWrapper(vector<int> & st,int i,int val)",
			"{",
			"    setSTVal(st,i,i+1,0,0,(st.size()+1)/2,val);",
			"}",
			"",
			"vector<int> initST(vector<int> & ar)",
			"{",
			"    int N = ar.size();",
			"    int sz = 1;",
			"    while(sz<N)sz<<=1;",
			"",
			"    vector<int> st(2*sz-1,nullval);",
			"    for(int i=0;i<N;i++)",
			"        setSTWrapper(st,i,ar[i]);",
			"",
			"    return st;",
			"}",
			""
		],
		"description": "Segment Tree Template"
	},

	  "custom_map": {
		"prefix": "custom_hash",
		"body": [
		  "struct custom_hash {",
		  "    static uint64_t splitmix64(uint64_t x) {",
		  "        x += 0x9e3779b97f4a7c15;",
		  "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
		  "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
		  "        return x ^ (x >> 31);",
		  "    }",
		  "",
		  "    size_t operator()(uint64_t x) const {",
		  "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
		  "        return splitmix64(x + FIXED_RANDOM);",
		  "    }",
		  "};"
		],
		"description": "custom_map"
	},

	  "Take Matrix Input": {
		"prefix": "maaaaaaatinp",
		"body": [
			"vector<vector<int>> mat(N,vector<int>(M));",
			"for(int i=0;i<N;i++)",
			"{",
			"    for(int j=0;j<M;j++)",
			"    {",
			"        cin>>mat[i][j];",
			"    }",
			"}"
		],
		"description": "Take Matrix Input"
	},
	"Disjoint Set Union Template": {
		"prefix": "DSU",
		"body": [
			"class DSU",
			"{",
			"public:",
			"",
			"    vector<int> P;    // Parent array",
			"    vector<int> rank; // Rank for union by rank heuristic",
			"    vector<int> sz;   // Size of the set (only valid for roots)",
			"    int num_disjoint_sets; // Current count of disjoint sets",
			"",
			"    DSU(int n) ",
			"    {",
			"        P.resize(n + 1);",
			"        std::iota(P.begin(), P.end(), 0);",
			"        rank.assign(n + 1, 1);",
			"        sz.assign(n + 1, 1);",
			"        num_disjoint_sets = n;",
			"    }",
			"",
			"    int getPar(int a)",
			"    {",
			"        if (P[a] == a) {",
			"            return a;",
			"        }",
			"        return P[a] = getPar(P[a]);",
			"    }",
			"",
			"    void unionS(int a, int b)",
			"    {",
			"        int l1 = getPar(a);",
			"        int l2 = getPar(b);",
			"",
			"        if (l1 == l2) ",
			"        {",
			"            return;",
			"        }",
			"",
			"        if (rank[l1] < rank[l2])",
			"        {",
			"            std::swap(l1, l2);",
			"        }",
			"",
			"        P[l2] = l1;",
			"        sz[l1] += sz[l2];",
			"        if (rank[l1] == rank[l2]) {",
			"            rank[l1]++;",
			"        }",
			"        num_disjoint_sets--;",
			"    }",
			"",
			"",
			"    int getSetSize(int a)",
			"    {",
			"        return sz[getPar(a)];",
			"    }",
			"",
			"    int getSz(int par)",
			"    {",
			"        return sz[par];",
			"    }",
			"",
			"    int getNumDisjointSets()",
			"    {",
			"        return num_disjoint_sets;",
			"    }",
			"};"
		],
		"description": "Disjoint Set Union Template"
	},

		"Palindrome checking": {
		"prefix": "Rabin_Karp",
		"body": [
			"    int power(int x, int y, int p)",
			"    {",
			"        int res = 1;",
			"        while (y > 0)",
			"        {",
			"            if (y % 2 == 1)",
			"            res = (res * x)%p;",
			"    ",
			"            y = y >> 1;",
			"            x = (x * x) % p;",
			"        }",
			"        return res % p;",
			"    }",
			"    ",
			"    int modInverse(int n,int MOD){return power(n, MOD - 2, MOD);}",
			"    ",
			"    bool is_palindrome(int l,int r,int* rabin1,int* rabin2,int N)",
			"    {",
			"        int comp1,comp2;",
			"        ",
			"        comp1 = rabin1[r];",
			"        comp2 = rabin2[l];",
			"        ",
			"        if(l!=0)comp1 = (comp1 - rabin1[l-1]+MOD)%MOD;",
			"        if(r!=N-1)comp2 = (comp2 - rabin2[r+1]+MOD)%MOD;",
			"        ",
			"        comp1 = (comp1*modInverse(power(31,l,MOD),MOD))%MOD;",
			"        comp2 = (comp2*modInverse(power(31,N - 1 - r,MOD),MOD))%MOD;",
			"        ",
			"        return comp1==comp2;",
			"    }",
			"",
			"        int rabin1[N],rabin2[N];",
			"        rabin1[0] = str[0]-'a',rabin2[N-1] = str[N-1]-'a';",
			"        ",
			"        int p = 31;",
			"        for(int i=1;i<N;i++)",
			"        {",
			"            rabin1[i] = (rabin1[i-1] + (str[i]-'a')*p)%MOD;",
			"            p = (p*31)%MOD;",
			"        }",
			"        ",
			"        p = 31;",
			"        for(int i=N-2;i>=0;i--)",
			"        {",
			"            rabin2[i] = (rabin2[i+1] + (str[i]-'a')*p)%MOD;",
			"            p = (p*31)%MOD;",
			"        }"
		],
		"description": "Palindrome checking"
	},
	"Transpose a Matrix": {
	"prefix": "transpose_mat",
	"body": [
		"void transpose(vector<vector<int>>& mat, vector<vector<int>>& res)",
		"{",
		"    int rows = mat.size();      ",
		"    int cols = mat[0].size();   ",
		"",
		"    res.resize(cols, vector<int>(rows));",
		"",
		"    for (int i=0;i<rows;i++)",
		"    {",
		"        for (int j=0;j<cols;j++)",
		"        {",
		"            res[j][i] = mat[i][j]; ",
		"        }",
		"    }",
		"}"
	],
	"description": "Transpose a Matrix"
	},

	"Grid Template": {
	"prefix": "gridFuncs",
	"body": [
		"vector<pair<int,int>> chngs = {{1,0},{0,1},{-1,0},{0,-1}};",
		"map<pair<int,int>,int> chngDict = {{{1,0},'D'},{{0,1},'R'},{{-1,0},'U'},{{0,-1},'L'}};",
		"",
		"vector<vector<pair<int,int>>> par(1000,vector<pair<int,int>> (1000));",
		"",
		"bool isValid(int i,int j,vector<vector<int>> & mat,vector<vector<int>> & vis)",
		"{",
		"    int N = mat.size(),M=mat[0].size();",
		"    return (i>=0 && i<N && j>=0 && j<M);",
		"}"
	],
	"description": "Grid Template"
},

	"Dijkstra": {
	"prefix": "dijkstra",
	"body": [
		"void dfs(int node,int sum,vector<vector<pair<int,int>>> & adj,vector<int> &ans,multiset<pair<int,int>> &s,int* vis)",
		"{",
		"    for(auto &v : adj[node])",
		"    {",
		"        if(vis[v.first] == 0)",
		"        {",
		"            s.insert({v.second + sum,v.first});",
		"        }",
		"        ans[v.first] = min(v.second + sum,ans[v.first]);",
		"    }",
		"    ",
		"    vis[node] = 1;",
		"    ",
		"    while(s.size() && vis[(*s.begin()).second]==1)",
		"    {",
		"        s.erase(s.begin());",
		"    }",
		"    ",
		"    if(s.size())",
		"    {",
		"        dfs((*s.begin()).second,(*s.begin()).first,adj,ans,s,vis);",
		"    }",
		"}",
		"",
		"vector<int> dijkstra(int V, vector<vector<pair<int,int>>> adj, int S)",
		"{",
		"    vector<int> ans(V+1,(int)1e15);",
		"    ",
		"    multiset<pair<int,int>> s;",
		"    ",
		"    int vis[V+1];",
		"    for(int i=1;i<=V;i++)vis[i] = 0;",
		"",
		"    ans[S] = 0;",
		"    dfs(S,0,adj,ans,s,vis);",
		"    ",
		"    return ans;",
		"}"
	],
	"description": "Dijkstra"
	},

"Floyd-Warshall": {
  "prefix": "floydn3",
  "body": [
    "void shortest_distance(vector<vector<int>>&matrix)",
    "{",
    "    int N = matrix.size();",
    "    for(int i=0;i<N;i++)",
    "    {",
    "        for(int j=0;j<N;j++)",
    "        {",
    "            if(matrix[i][j] == -1)matrix[i][j] = 1e9;",
    "        }",
    "    }",
    "    ",
    "    for(int k=0;k<N;k++)",
    "    {",
    "        for(int i=0;i<N;i++)",
    "        {",
    "            for(int j=0;j<N;j++)",
    "            {",
    "                matrix[i][j] = min(matrix[i][j],matrix[i][k] + matrix[k][j]);",
    "            }",
    "        }",
    "    }",
    "    ",
    "    for(int i=0;i<N;i++)",
    "    {",
    "        for(int j=0;j<N;j++)",
    "        {",
    "            if(matrix[i][j] == 1e9)matrix[i][j] = -1;",
    "        }",
    "    }",
    "}",
    ""
  ],
  "description": "Floyd-Warshall"
}
}
